import random

from Schedule import Schedule
from Datatypes.Day import Day
from datetime import datetime, time, timedelta

from Datatypes.SlotType import SlotType
from Slot import Slot
from State import State

# set to True to see which HC are failing
debug_global = False


def convert_or_tree_to_genetic(or_tree_assignments):
    """
    a helper function which converts an Or-Tree-based schedule back into a genetic algorithm-based Schedule object.

    :param or_tree_assignments: this is the final schedule that we got from our or-tree creating function
    :return: this will return a schedule in the form of the GA schedule for the rest of the code, so there isn't any formatting issues
    """

    # create a new dummy schedule that we want to fill in
    new_schedule = Schedule(State.games, State.practices)
    
    # then we want to iterate through all of the assignment our schedule one by one to add to the GA schedule
    for division, slot in or_tree_assignments.items():

        # since a slot can be either one slot if it is the only game at that time or it can be a list of slots if there are more than one game or practice in a slot
        # this checks to see if it is only one slot
        if not isinstance(slot, list):
            # create a slot object to add to the GA schedule from the information from our own slot
            slot_obj = State.lookup_simple_slots(slot.get_type(), slot.get_day(), slot.get_time())
            # then we want to add this game to our GA schedule
            new_schedule.add_assign(division, slot_obj)
        # otherwise we are looking at a list of slots, so we want to process that list
        else:
            # here we go through every slot in our list one by one
            for individual_slot in slot:
                # here we create a slot object from our given slot to add to our GA schedule
                slot_obj = State.lookup_simple_slots(individual_slot.get_type(), individual_slot.get_day(), individual_slot.get_time())
                # then we add this assignment to our GA schedle
                new_schedule.add_assign(division, slot_obj)
    
    # then when we are finished we return our GA schedule
    return new_schedule


def is_valid_slot(slot, assignments, game):
    """
    this is a helper function which will check all of the hard constraints are met for the scheudule
    
    :param slot: the slot that we wish to check
    :param assignments: the current schedule that we have so far it could vary in levels of incompleteness from empty all the way to fully filled in
    :param game: the current game/prac that we are checking
    :return: true if all the hard constraints are met for the schedule or false otherwise
    """

    # If any of these return true then it is not a valid schedule
    # Works like the constr() function from paper
    if (GHC1(slot, assignments,)
        or assign_conflict(slot, assignments, game)
        or notCompatible(slot, assignments, game)
        or GHC5(slot, game)
        or GHC6(slot, game)
        or adminMeetingConflict(slot)
        or violatesEvening(slot, game)
        or violatesOverlap(slot, assignments, game)
        or violatesSpecialAssignment(assignments)
        or violatesSpecialOverlap(slot, game)
        ):
        if debug_global:
            print("DEBUG: Failed A HC")
            print("^^^FAILED THIS ONE")
        return False
    else:
        if debug_global:
            print("DEBUG: PASSED ALL HC")
        return True
        


def dfs_schedule(assignments, game_list, fast_game_list, GA_assignments, current_index = 0, leaf_var=0, for_var=0):
    """
    here we do the DFS or-tree to try and fix the GA schedule if required and make sure it follows all of the hard constraints

    :param assignments: the current schedule that we have so far dict[str, list[slot]]
    :param game_list: the list of games from the orignal schedule list[str]
    :param fast_game_list: list[(str, int)] produced by fastOrTree. Ordered to optimize speed
    :param GA_assignments: dict[str, list[slot]] the schedule generated by the GA
    :param current_index: int, the index of the game that we wish to assign 
    :param leaf_var: (debugging variable) int, keeps track of how many times we recurse through fleaf (GA assignment did work)
    :param for_var: (debugging variable) int, keeps track of how many times we recurse through fleaf (GA assignment did not work)
    :return: a valid schedule, so either the original schedule or, a new schedule that satisfies the hard constraints or none
    """

    # first we check to see if we made it to the end of the schedule by checking if the index is the same value as the size of the amount of games we need to check
    if current_index == len(game_list):
        # return the schedule that now meets all the hard constraints
        return assignments
    
    # this will be the current game or practice that we want to check the slot of
    game = fast_game_list[0][0]
    
    # then we want to see what the available slots are that we can put the the game or practice is
    available_slots = fast_get_available_slots(fast_game_list)

    # Then we need to remove the game or practice from our queue of things that need to be scheduled
    fast_game_list = fast_game_list[1:]

    # Now we want to check each slot and see if we can validate its hard constraints

    # We need fleaf to check the slots assignment by GA first
    # fleaf() will give us the slot that the current game has been assigned to
    # This is written as fleaf_slots being a list to handle the situation where
    # we end up with more than one slot for a game/prac (duplicate games etc)
    # In realilty fleaf_slots should be length 1 and for loop only runs once
    fleaf_slots = fleaf(GA_assignments, game)
    for slot in fleaf_slots:
        # Assign the slot
        assignments[game] = [slot]
        # Check the hard constraints
        if is_valid_slot(slot, assignments, game):
            # if it does pass the hard constraints then we want to go to the next depth in our or-tree
            result = dfs_schedule(assignments, game_list, fast_game_list, GA_assignments, current_index + 1,leaf_var+1, for_var)
            # then we check if the schedule we have is not none
            if result:
                # if it is not none then we know we have a valid schedule and we can return it
                return result
        
        # if the game doesn't work in this slot, then we want to remove it and then try again
        del assignments[game]

    # Here we shuffle our available slots so the for loop is randomly checking
    # a slot instead of checking slots based on the order we parse them
    random.shuffle(available_slots)

    # Now we iterate over the slots to see if our game/practice will work in any of them
    # This is DFS so this for loop will not iterate through every thing unless we have a worst case
    # Instead, it will return at some point during the iteration
    for slot in available_slots:

        # Assign a slot
        assignments[game] = [slot]
        # then we check if having added this game to this slot still has a schedule that passes all of the hard constraints
        if is_valid_slot(slot, assignments, game):
            # if it does pass the hard constraints then we want to go to the next depth in our or-tree
            result = dfs_schedule(assignments, game_list, fast_game_list, GA_assignments, current_index + 1, leaf_var, for_var + 1)
            # then we check if the schedule we have is not none
            if result:
                # if it is not none then we know we have a valid schedule and we can return it
                return result
        
        del assignments[game]

    # if no valid solution was found then we want to return none
    return None


def or_tree_repair(assignments):
    """
    this is the or tree that tries to validate the schedule/fix any issues, or tells us if the schedule will not work

    :param assignments: the initial genetic algorithm schedule
    :return: either the same schedule back if it is fully valid, a modified GA schedule if the original one violated some hard constraints or none if we cannot validate the schedule
    """

    # start with an empty schedule - as we haven't tried anything yet, and this should vacously satisfy the hard constraints
    empty_assignments = {}
    
    # get a list of all the keys of the GA schedule - this is all of the division names such as "CMSA U13T3 DIV 01"
    game_list = list(assignments.keys())
    
    # Here we are getting the queue of games/practices that need to be checked
    # This is ordered in a way that optimizes for speed and tries to shrink the 
    # size of the fringe and number of nodes we need to check
    fast_game_list = fastOrTree(game_list)

    # here we call the depth first search to see if we can validate the schedule, we give it the empty list, and all of the keys
    valid_schedule = dfs_schedule(empty_assignments, game_list, fast_game_list, assignments)


    # after we return we check if dfs_schedule() returned none or not, if it didn't return none then we found a schedule that works, which means that we want to retrn it
    if valid_schedule:
        # here we return the schedule, we first convert it back to a GA schedule and then return it
        return convert_or_tree_to_genetic(valid_schedule)
    # in this case we have returned none, so we couldn't find a schedule that is valid, so we want to return none
    else:
        # debugging print statement to let us know where we are in the code
        print("No valid schedule could be found.")
        return None


def fastOrTree(game_list):
    """
    A helper function that essentially creates a priority queue of games/practices
    ordered by their likelyhood to fail hard constraints. 
    We need to order them most likely to least likely in order to optimize the speed of the or tree.
    By handling the most likely to fail first, we can deal with these failures early in the tree
    when the fringe is smaller and there are more open slots for us to choose from. 
    This means we can schedule these first without having to backtrack and check a bajillion nodes.
    We order the list as specials first because these must be assigned at 18:00 so there's no point checking
    a schedule where these slots are taken.
    Then we have night games, because they must go at night so theres no point checking a schedule where 
    all night slots are taken.
    Then we add the list of everything else, which is ordered by the number of non-compatible relationships
    the game/prac is present in. 

    :param game_list: list of all the games/practices 
    :return: list[(str, int)] where str is game/prac and int is the number of HC relationships the game/prac has
    """

    # rev makes it sort in descending order ie. likely to fail -> not likely to fail
    rev = True
    constraint_abs = []
    night_abs = []
    specials = []
    # loop through the games
    for field_identifier in game_list:

        # Get the Field object for the game/prac
        gp = State.lookup_games_and_practices(field_identifier)
        gp_div = gp.get_div()

        # If evening game add to evening list
        if gp_div[0] == '9':
            gp_non_compatibles = gp.get_not_compatible()
            night_abs.append((field_identifier, len(gp_non_compatibles)))

        # else if special add to special list
        elif "CMSA U12T1S" in field_identifier or "CMSA U13T1S" in field_identifier:
            specials.append((field_identifier, 1))

        # else just find the amount of non-compatible relationships it has and add to list
        else:
            gp_non_compatibles = gp.get_not_compatible()
            constraint_abs.append((field_identifier, len(gp_non_compatibles)))

    # Here we sort our lists in order of likely to fail -> not likely to fail 
    sorted_night_abs = sorted(night_abs, key=lambda x: x[1], reverse=rev)
    sorted_constraint_abs = sorted(constraint_abs, key=lambda x: x[1], reverse=rev)

    # add the lists all together and return
    return specials + sorted_night_abs + sorted_constraint_abs
    

def fast_get_available_slots(fast_game_list):
    """
    a helper function that gets the available slots that a game/prac can have, then it returns a flattened version of the schedule 

    :param fast_game_list: our queue of things needed to be checked/scheduled
    :return: a flattened list of available slots for the game or practice
    """

    # first we check to make sure that the index still fits in the schedule, and that we won't be going out of rance 
    if 0 >= len(fast_game_list):
        # raise an error if we will be going out of range, we should never get here, but just in case
        raise IndexError("Index out of range for the game list.")

    # Get the game at the front of the queue
    game = fast_game_list[0][0]

    # then we want to know if the item we want to schedule is a game or practice
    if "PRC" in game or "OPN" in game: 
        # if it is of type practice then we want to return all of the time slots that or of type practice or an empty dictionary if there are none
        slot_dict = State.lookup_simple_slot(SlotType.PRACTICE) or {}
    # otherwise we want to check to see if we are looking at games
    elif "DIV" in game:
        # if we are looking at a game then we want to return all of the time slots that are available for games or an empty dictionary if there are none
        slot_dict = State.lookup_simple_slot(SlotType.GAME) or {}
    # otherwise we have "CMSA U12T1S or CMSA U13T1s"
    else:
        # therefore we need to return practices since these are "special practices"
        slot_dict = State.lookup_simple_slot(SlotType.PRACTICE) or {}
    
    # then we will flatten the dictionary that we have been given into a list, so that it is more usable
    available_slots = [slot for slots in slot_dict.values() for slot in slots]
    
    # then we want to return that list
    return available_slots



def fleaf(GA_assignments, game):
    """
    fleaf just checks what slot the GA assigned for a game/prac so we can check this first
    :param GA_assignments: the schedule created by the GA
    :param game: the current game/prac that we are checking
    :return: a list of slots (should only be length 1) that the game/prac has been scheduled at by GA
    """
    # Guard 
    if game not in GA_assignments:
        return []
    
    # Find the slot that the GA assigned to the game/prac
    slots = GA_assignments[game]
    return slots


def GHC1(slot, assignments):
    """
    Function checking General HC 1
    :param slot: Slot object that we are checking
    :param assignments: the current schedule the or-tree has built
    :return: True if fails HC, False if passes HC
    """

    gp_slot = slot
    # Get the slot identifier
    slot_identifier = gp_slot.get_identifier()
    gamemax = gp_slot.get_max()

    # counter for how many times the slot is assigned in the or tree
    # Keep in mind, we are starting at 0 because the game/prac and slot we are dealing with
    # on this level is already scheduled in assignments
    count = 0

    # loop over all the slots currently assigned in the or-tree
    for slot_list in assignments.values():
        # this only runs once as slot_list should be len 1
        for as_slot in slot_list:
            # if we see the slot we are currently interested in, update the counter
            if slot_identifier == as_slot.get_identifier():
                count += 1

    # return True if we fail the HC
    if gamemax < count:
        if debug_global: 
            print("DEBUG: FAILED GHC1")
        return True
    else:
        return False
    


def assign_conflict(slot, assignments, game):
    """
    Function to check GHC 3. assign(gi) != assign(piki). 
    Can't schedule a game and a practice in overlapping times for same teams
    :param slot: the slot we are dealing with
    :param assignments: the current schedule the or-tree has built
    :param game: the str of the game/prac we are assigning a slot to
    :return: True if fails HC, False if passes HC
    """

    field_identifier = game
    gp_slot = slot
    # Here we need the info about when the slot takes place
    gp_slot_start_time = gp_slot.get_time()
    gp_slot_end_time = get_end_time(gp_slot)
    gp_slot_day = gp_slot.get_day()

    # Now we need the Field object of the game/prac
    gp = State.lookup_games_and_practices(field_identifier)
    gp_league = gp.get_league()
    gp_tier = gp.get_tier()
    gp_div = gp.get_div()

    if gp_slot.get_type() == 'p':
        # create a partial game identifier
        id = f"{gp_league} {gp_tier} DIV {gp_div}"

        # Loop over things scheduled
        for key in assignments:

            # If we have a matching game to our practice
            if id in key:
                for a_slot in assignments[key]:
                    # Check if game slots or practice slots
                    # We don't want to be checking practices here 
                    # we only want to check games
                    if a_slot.get_type() == 'p':
                        continue

                    # compare to gp_slot 
                    # If they start at the same time we know this is going to fail 
                    if (gp_slot.get_day() + gp_slot.get_time().strftime("%H:%M:%S")) == (a_slot.get_day() + a_slot.get_time().strftime("%H:%M:%S")):
                        # Then the team has a game and practice starting at same time same day
                        if debug_global: 
                            print("DEBUG: FAILED assign_conflict matching practice")
                        return True

                    # Now we need to check overlapping times
                    check_slot_start_time = a_slot.get_time()
                    check_slot_end_time = get_end_time(a_slot)
                    check_slot_day = a_slot.get_day()

                    # time_overlap == True when overlap occurs
                    if time_overlap(gp_slot_start_time, 
                                    gp_slot_end_time, 
                                    gp_slot_day,
                                    check_slot_start_time, 
                                    check_slot_end_time,
                                    check_slot_day):

                        if debug_global:
                            print("DEBUG: FAILED assign_conflict overlap practice")
                        return True
        return False
                    
    elif gp_slot.get_type() == 'g':
        # create partial practice identifier
        if gp_div == "0":
            id = f"{gp_league} {gp_tier}"
        else:
            id = f"{gp_league} {gp_tier} DIV {gp_div}"
        
        # Loop over things scheduled
        for key in assignments:
            # If we have a matching practice
            if id in key:
                for a_slot in assignments[key]:
                    # Check if game slots or practice slots
                    # We don't want to be checking games here 
                    # we only want to check practices
                    if a_slot.get_type() == 'g':
                        continue

                    # compare to gp_slot 
                    # If they start at the same time we know this is going to fail 
                    if (gp_slot.get_day() + gp_slot.get_time().strftime("%H:%M:%S")) == (a_slot.get_day() + a_slot.get_time().strftime("%H:%M:%S")):
                        # Then the team has a game and practice starting at same time same day
                        if debug_global:
                            print("DEBUG: FAILED assign_conflict")
                        return True
                    # Now we need to check overlap
                    check_slot_start_time = a_slot.get_time()
                    check_slot_end_time = get_end_time(a_slot)
                    check_slot_day = a_slot.get_day()
                    # time_overlap == True when overlap occurs
                    if time_overlap(gp_slot_start_time, 
                                    gp_slot_end_time,
                                    gp_slot_day, 
                                    check_slot_start_time, 
                                    check_slot_end_time,
                                    check_slot_day):
                        if debug_global:
                            print("DEBUG: FAILED assign_conflict")
                        return True
        return False
    else:
        print("Slot error in assign_conflict")

    return False


def notCompatible(slot, assignments, game):
    """
    Function to check GHC 4. assign(a) != assign(b) if a + b non compatible. 
    :param slot: the slot we are dealing with
    :param assignments: the current schedule the or-tree has built
    :param game: the str of the game/prac we are assigning a slot to
    :return: True if fails HC, False if passes HC
    """

    field_identifier = game
    gp_slot = slot
    gp_slot_start_time = gp_slot.get_time()
    gp_slot_end_time = get_end_time(gp_slot)
    gp_slot_day = gp_slot.get_day()
    gp = State.lookup_games_and_practices(field_identifier)
    # list of non-compatibles of type Game/Practice
    nc = gp.get_not_compatible()
    nc_identifiers = []

    # get the day and time of the slot
    gp_slot_dt = gp_slot.get_day() + gp_slot.get_time().strftime("%H:%M:%S")
    # get the identifiers for the NC games / practices
    for item in nc:
        identifier = item.get_identifier()

        # used in overlap for loop
        nc_identifiers.append(identifier)

        # Guard
        if identifier in assignments:
            # get the assigned slots
            assigns = assignments[identifier]

            for assign in assigns:

                # We don't want the full identifier because we need to check 
                # practices with games not just p-p g-g
                # So we just get the day and time 
                assign_dt = assign.get_day() + assign.get_time().strftime("%H:%M:%S")
                
                # If they start at same time we fail this HC
                if assign_dt == gp_slot_dt:
                    if debug_global:
                        print("DEBUG: FAILED notCompatible SCHEDULE ERROR")
                    return True


                
    # Now we check the overlap
    for key in assignments:
        # Get the Practice/Game object associated with key string
        key_field = State.lookup_games_and_practices(key)

        # Get the Field Identifier and check if it is a non compatible
        if (key_field.get_identifier() in nc_identifiers):
            # Loop over the Slot objects assigned to the non compatible field (key)
            for item in assignments[key]:
                # We need the start time and end time
                check_slot_start_time = item.get_time()
                check_slot_end_time = get_end_time(item)
                check_slot_day = item.get_day()  
                # time_overlap == True when overlap occurs
                if time_overlap(gp_slot_start_time, 
                                gp_slot_end_time, 
                                gp_slot_day,
                                check_slot_start_time, 
                                check_slot_end_time,
                                check_slot_day):
                    if debug_global:
                        print("DEBUG: FAILED notCompmpatible OVERLAP")
                    return True
    # If we haven't returned True yet then we're all good
    return False

def get_end_time(slot: Slot):
    """
    Helper function that finds the end time of a slot
    :param slot: a slot object
    :return: time object of the end time
    """
    start_time = slot.get_time()
    day = slot.get_day()
    s_type = slot.get_type()
    if s_type == 'p':
        if day == Day.MONDAY or day == Day.WEDNESDAY:
            end_time = add_time(start_time, hours=1)
        elif day == Day.TUESDAY or day == Day.THURSDAY:
            end_time = add_time(start_time, hours=1)
        elif day == Day.FRIDAY:
            end_time = add_time(start_time, hours=2)
        else:
            print("Error in get_end_time practice")
    elif s_type == 'g':
        if day == Day.MONDAY or day == Day.WEDNESDAY:
            end_time = add_time(start_time, hours=1)
        elif day == Day.TUESDAY or day == Day.THURSDAY:
            end_time = add_time(start_time, hours=1, minutes=30)
        elif day == Day.FRIDAY:
            end_time = add_time(start_time, hours=1)
        else:
            print("Error in get_end_time games")

    else:
        print("Error in get_end_time with slot type")
    return end_time


def add_time(base_time: time, hours: int = 0, minutes: int = 0):
    """
    Helper function to add a time to a time object
    This function was made using the help of ChatGPT to help with the time object typing
    :param base_time: the initial time you are working with
    :param hours: how many hours you want to add
    :param minutes: how many minutes you want to add
    :return: new time object
    """

    # here we just convert everything into minutes
    total_minutes = base_time.hour * 60 + base_time.minute + hours * 60 + minutes

    # Probably don't need this it just handles wrap around if we are trying to add more
    # than a days worth of minutes 
    total_minutes %= 1440

    # extract the hours
    new_hour = total_minutes // 60
    # extract the minutes
    new_minute = total_minutes % 60

    # return the updated time object
    return time(new_hour, new_minute)


def time_overlap(start_time_1, end_time_1, day_1, start_time_2, end_time_2, day_2):
    """
    Helper function to determine if two time slots overlap
    :param start_time_1: time object
    :param end_time_1: time object
    :param day_1: str
    :param start_time_2: time object
    :param end_time_2: time object
    :param day_2: str
    :return: True if overlap. False if no overlap.
    """
    # If not on same day then no overlap and return false
    if day_1 == day_2:
        # Main logic of the overlap. 
        # Can easily be verified when drawn on paper
        # Hard to explain in words
        if (start_time_1 < end_time_2 and start_time_2 < end_time_1):
            return True
    return False


def GHC5(slot, game):
    """
    Function to check GHC 5. assign(a) = partassign(a). 
    Partial assignments must hold
    :param slot: the slot we are dealing with
    :param game: the str of the game/prac we are assigning a slot to
    :return: True if fails HC, False if passes HC
    """
    # if there is a partial assign -> then make sure we are matching it
    field_identifier = game
    gp_slot = slot
    gp = State.lookup_games_and_practices(field_identifier)
    partial_assign = gp.get_partial_assign()
    # if we have no partial assignments just exit
    if partial_assign is None:
        return False
    # if we get there then there are partial assignmetns
    # so just check the slot identifier with the partial assignments identifier
    # and if they're not the same we failed this HC
    if gp_slot.get_identifier() != partial_assign.get_identifier():
        if debug_global:
            print("DEBUG: FAILED GHC5")
        return True
    return False


def GHC6(slot, game):
    """
    Function to check GHC 6. assign(a) != s if unwanted(a,s). 
    Can't schedule something into and unwanted slot
    :param slot: the slot we are dealing with
    :param game: the str of the game/prac we are assigning a slot to
    :return: True if fails HC, False if passes HC
    """

    # if there is unwanted then we make sure we are not assigning to this
    field_identifier = game
    gp_slot = slot

    # get the Field object
    gp = State.lookup_games_and_practices(field_identifier)

    # Get the unwanted slots from the Field object
    unwanteds = gp.get_unwanted() 

    # loop through unwanted slots
    for unwanted in unwanteds:
        # If the slot we have scheduled is an unwanted slot we fail this HC
        if gp_slot.get_identifier() == unwanted.get_identifier():
            if debug_global:
                print("DEBUG: FAILED GHC6")
            return True
    return False


def adminMeetingConflict(slot):
    """
    Function to check Calgary admin meeting HC. No games can happen 11am - 12:30 on TU And TH. 
    :param slot: the slot we are dealing with
    :return: True if fails HC, False if passes HC
    """
    gp_slot = slot

    # Check that we are dealing with a game
    if gp_slot.get_type() == 'g':
        gp_day = gp_slot.get_day()
        # Only worry about TU and TH
        if (gp_day == "TU" or gp_day == "TH"):
            gp_time = gp_slot.get_time()
            # We don't have to worry about overlap, only worry about start time
            if gp_time == time(11,0):
                if debug_global:
                    print("DEBUG: FAILED adminMeetingConflict")
                return True
    return False

def violatesEvening(slot, game):
    """
    Function to check Calgary Hard Constraint.
    Teams with DIV 9_ must be scheduled to the evening 
    Can't schedule a game and a practice in overlapping times for same teams
    :param slot: the slot we are dealing with
    :param game: the str of the game/prac we are assigning a slot to
    :return: True if fails HC, False if passes HC
    """

    field_identifier = game
    gp_slot = slot

    # First check if its div 9 and needs to be in the evening
    gp = State.lookup_games_and_practices(field_identifier)
    gp_div = gp.get_div()
    if gp_div[0] == '9':
        gp_time = gp_slot.get_time()
        # Check if evening slot or not
        if gp_time < time(18,0):
            if debug_global:
                print("DEBUG: FAILED violatesEvening")
            return True
    return False




def violatesOverlap(slot, assignments, game):
    """
    Function to check Calgary overlapping games for U15/U16/U17/U19. 
    These games can not be overlapping
    :param slot: the slot we are dealing with
    :param assignments: the current schedule the or-tree has built
    :param game: the str of the game/prac we are assigning a slot to
    :return: True if fails HC, False if passes HC
    """
    field_identifier = game
    gp_slot = slot
    gp = State.lookup_games_and_practices(field_identifier)
    # this HC only deals with games so if practice return False
    if gp_slot.get_type() == 'p':
        return False

    tiers_list = ['U15', 'U16', 'U17', 'U19']

    # Need the [:-2] to remove the T2 or whatever from U15T2
    gp_tier = gp.get_tier()[:-2]

    # if not in these tiers we don't need to check HC
    if gp_tier not in tiers_list:
        return False


    for tier in tiers_list:
        # Get all the games for this tier
        field_list = State.lookup_games_by_tier(tier)


        # NOTE: This may be too strict???
        # Currently this checks all games across all the tiers
        # So if our original input to function was U15T1 this will return True
        # if U15T2 is scheduled at the same time
        # If we want to allow U15T2 and U15T1 to overlap then add the 2 lines below
        for field in field_list:
            # NOTE: In order to make the HC less strict, this is what needs to be added
            # if gp_tier == field.get_tier()[:-2]:
            #     continue
            
            # This just ensures we aren't checking our game from dict against itself (passed in to fucntion)
            check_id = field.get_identifier()
            if check_id == field_identifier:
                continue
            # Guard against key error
            if check_id not in assignments:
                continue
            # check their slot assignments
            temp_slots = assignments[check_id]
            # for each of the slot assignments
            for temp_slot in temp_slots:
                # Check if it is the same slot as our original slot
                if gp_slot.get_identifier() == temp_slot.get_identifier():
                    if debug_global:
                        print("gp identifier: ", gp_slot.get_identifier())
                        print("temp identifier: ", temp_slot.get_identifier())
                        print("DEBUG: FAILED violatesOverlap")
                    return True

    return False

    
def violatesSpecialAssignment(assignments):
    """
    This is a hard constraint function which checks for the special assignment hard constraint that both "CMSA U12T1S" and "CMSA U13T1S" have to have practice at a certain time

    :param assignments: this is the current schedule that we have
    :return: returns false if the hard constraint is not violated and returns true if it is
    """
    # here we iterate through the schedule to see if we find the special cases
    for key, value in assignments.items():
        # here we check to see if the special practices exist in the schedule
        if "CMSA U12T1S" in key or "CMSA U13T1S" in key:
            for scheduled_slot in value:
                # if they do exist we check to see if they violate the hard constraint
                if scheduled_slot.get_type() == "g" or scheduled_slot.get_day() == "MO" or scheduled_slot.get_day() == "FR" or scheduled_slot.get_day() == "WE" or scheduled_slot.get_time() != time(18, 0):
                    # if it violates the hard constraint we return True
                    return True
    #otherwise we return False
    return False


def violatesSpecialOverlap(slot, game):
    """
    Function to check overlapping of special practices with their regular game/pracs. 
    :param slot: the slot we are dealing with
    :param game: the str of the game/prac we are assigning a slot to
    :return: True if fails HC, False if passes HC
    """
    field_identifier = game
    # get info for our slot
    gp_slot = slot
    gp_slot_start_time = gp_slot.get_time()
    gp_slot_end_time = get_end_time(gp_slot)
    gp_slot_day = gp_slot.get_day()
    gp = State.lookup_games_and_practices(field_identifier)
    special_start = time(18,0) # hardcode start time to 18:00
    special_end = time(19,0) # hardcode end time to 19:00
    special_day = 'TU'
    special_day_2 = 'TH'
    # Here we are checking to make sure we don't schedule any CMSA U13/12T1 in an 
    # overlapping slot with the specials
    # If we aren't one of these then we don't care
    if 'CMSA U13T1' not in field_identifier and 'CMSA U12T1' not in field_identifier:
        return False
    
    # If it's a special we don't want to check it with itself or it will fail
    if 'CMSA U13T1S' in field_identifier or 'CMSA U12T1S' in field_identifier:
        return False

    # Now we need to check the overlap
    if (time_overlap(gp_slot_start_time,
                    gp_slot_end_time,
                    gp_slot_day,
                    special_start,
                    special_end,
                    special_day)
        or 
        time_overlap(gp_slot_start_time,
                    gp_slot_end_time,
                    gp_slot_day,
                    special_start,
                    special_end,
                    special_day_2)):
        return True

    return False
